<!DOCTYPE html>
<html>
  <head>
    <title>P2P Chat</title>
    <meta charset="utf-8" />
    <link href="css/chat.css" rel="stylesheet" />
  </head>
  <body>
    <h1>P2P Chat Room</h1>

    <div>
      <h2>Online Peers</h2>
      <button onclick="loadPeers()">Refresh</button>
      <div id="peerList"></div>
    </div>

    <div>
      <h2>Channels</h2>
      <button onclick="loadChannels()">Refresh</button>
      <input type="text" id="newChannel" placeholder="Channel name" />
      <button onclick="createChannel()">Create</button>
      <div id="channelList"></div>
    </div>

    <div>
      <h2>Direct Message</h2>
      <input type="text" id="directTo" placeholder="peer_5001" />
      <input type="text" id="directMsg" placeholder="Message" />
      <button onclick="sendDirect()">Send</button>
    </div>

    <div>
      <h2>Broadcast</h2>
      <input type="text" id="broadcastMsg" placeholder="Message" />
      <button onclick="sendBroadcast()">Broadcast</button>
    </div>

    <div>
      <h3>Status</h3>
      <div id="status"></div>
    </div>

    <div>
      <h2>Messages</h2>
      <div id="messages"></div>
    </div>

    <!-- Channel chat windows container -->
    <div id="channelWindows"></div>

    <script>
      let lastPeerCount = 0;
      let lastChannelCount = 0;
      let lastMessageCount = 0;
      let lastMessageTimestamp = 0;
      let handshakes = {};
      let currentPeerId = null;
      let channelWindows = {}; // Track open channel windows
      let channelWindowPositions = {}; // Track window positions

      async function request(method, path, data = null) {
        try {
          const options = {
            method: method,
            headers: { "Content-Type": "application/json" },
          };
          if (data && method === "POST") {
            options.body = JSON.stringify(data);
          }
          const res = await fetch(path, options);
          return await res.json();
        } catch (e) {
          console.error(e);
          return { status: "error", message: e.message };
        }
      }

      function showStatus(msg) {
        document.getElementById("status").textContent = msg;
        setTimeout(() => {
          document.getElementById("status").textContent = "";
        }, 3000);
      }

      async function loadPeers() {
        const data = await request("GET", "/api/peers");
        const handshakeData = await request("GET", "/api/handshakes");

        if (handshakeData.status === "success") {
          handshakes = handshakeData.handshakes || {};
        }

        if (data.status === "success" && data.peers) {
          if (data.peers.length !== lastPeerCount) {
            lastPeerCount = data.peers.length;
            let html = "<ul>";
            data.peers.forEach((p) => {
              const isCurrentPeer = p.id === currentPeerId;
              const isHandshaked = handshakes[p.id]?.status === "accepted";
              const statusClass = isHandshaked
                ? "handshake-accepted"
                : "handshake-none";
              const statusText = isHandshaked ? "âœ“ Connected" : "Not Connected";

              html +=
                "<li" + (isCurrentPeer ? ' class="current-peer"' : "") + ">";
              html += p.username + " (" + p.id + ") - " + p.ip + ":" + p.port;

              // Only show status and connect button if not current peer
              if (!isCurrentPeer) {
                html +=
                  '<span class="handshake-status ' +
                  statusClass +
                  '">' +
                  statusText +
                  "</span>";

                if (!isHandshaked) {
                  html +=
                    " <button onclick=\"doHandshake('" +
                    p.id +
                    "')\">Connect</button>";
                }
              } else {
                html += ' <span style="color: #1976d2;">(You)</span>';
              }

              html += "</li>";
            });
            html += "</ul>";
            document.getElementById("peerList").innerHTML = html;
          }
        }
      }

      async function doHandshake(peerId) {
        showStatus("Connecting to " + peerId + "...");
        const data = await request("POST", "/api/handshake", {
          peer_id: peerId,
        });

        if (data.status === "success") {
          showStatus(
            "Connected with " +
              peerId +
              " (" +
              (data.peer_username || "Unknown") +
              ")"
          );
          loadPeers();
        } else {
          showStatus("Connection failed: " + (data.message || "Unknown error"));
        }
      }

      async function loadChannels() {
        const data = await request("GET", "/api/channels");
        if (data.status === "success" && data.channels) {
          if (data.channels.length !== lastChannelCount) {
            lastChannelCount = data.channels.length;
            let html = "";
            data.channels.forEach((c) => {
              html += '<div class="channel-list-item">';
              html += "<div>";
              html += "<strong>" + c.name + "</strong>";
              html += " (Owner: " + c.owner + ", Members: " + c.members + ")";
              html += "</div>";
              html += "<div>";
              html +=
                "<button onclick=\"joinChannel('" +
                c.name +
                "')\">Join</button>";
              html +=
                "<button onclick=\"openChannelWindow('" +
                c.name +
                "')\">Open Chat</button>";
              html += "</div>";
              html += "</div>";
            });
            document.getElementById("channelList").innerHTML = html;
          }
        }
      }

      // Open channel chat window
      function openChannelWindow(channelName) {
        // Check if window already exists
        if (channelWindows[channelName]) {
          // Just show it
          channelWindows[channelName].classList.add("active");
          return;
        }

        // Create new channel window
        const windowId = "channel-window-" + channelName;
        const windowDiv = document.createElement("div");
        windowDiv.id = windowId;
        windowDiv.className = "channel-window active";

        // Calculate position (cascade windows)
        const offset = Object.keys(channelWindows).length * 30;
        const left = 100 + offset;
        const top = 100 + offset;
        const width = 400;
        const height = 450;

        windowDiv.style.left = left + "px";
        windowDiv.style.top = top + "px";
        windowDiv.style.width = width + "px";
        windowDiv.style.height = height + "px";

        channelWindowPositions[channelName] = { left, top };

        windowDiv.innerHTML = `
          <div class="channel-header" id="header-${channelName}">
            <h3>Channel: ${channelName}</h3>
            <button class="channel-close" onclick="closeChannelWindow('${channelName}')">âœ•</button>
          </div>
          <div class="channel-messages" id="channel-messages-${channelName}"></div>
          <div class="channel-input-area">
            <input type="text" id="channel-input-${channelName}" placeholder="Type a message..." 
                   onkeypress="if(event.key==='Enter') sendChannelMessage('${channelName}')">
            <button onclick="sendChannelMessage('${channelName}')">Send</button>
          </div>
        `;

        document.getElementById("channelWindows").appendChild(windowDiv);
        channelWindows[channelName] = windowDiv;

        // Make window draggable
        makeDraggable(windowDiv, channelName);

        // Start polling for this channel's messages
        startChannelMessagePolling(channelName);

        // Auto-join the channel
        joinChannel(channelName);
      }

      // Close channel window
      function closeChannelWindow(channelName) {
        if (channelWindows[channelName]) {
          channelWindows[channelName].remove();
          delete channelWindows[channelName];
          delete channelWindowPositions[channelName];
        }
      }

      // Make window draggable
      function makeDraggable(windowDiv, channelName) {
        const header = document.getElementById("header-" + channelName);
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;

        header.addEventListener("mousedown", dragStart);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", dragEnd);

        function dragStart(e) {
          initialX = e.clientX - channelWindowPositions[channelName].left;
          initialY = e.clientY - channelWindowPositions[channelName].top;

          if (e.target === header || e.target.tagName === "H3") {
            isDragging = true;
          }
        }

        function drag(e) {
          if (isDragging) {
            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;

            channelWindowPositions[channelName].left = currentX;
            channelWindowPositions[channelName].top = currentY;

            windowDiv.style.left = currentX + "px";
            windowDiv.style.top = currentY + "px";
          }
        }

        function dragEnd() {
          isDragging = false;
        }
      }

      // Send message to channel
      async function sendChannelMessage(channelName) {
        const input = document.getElementById("channel-input-" + channelName);
        const msg = input.value.trim();

        if (!msg) return;

        const data = await request("POST", "/api/channel/send", {
          channel: channelName,
          message: msg,
        });

        if (data.status === "success") {
          input.value = "";
          updateChannelMessages(channelName);
        } else {
          showStatus("Error: " + (data.message || "Failed to send"));
        }
      }

      // Poll for channel messages
      async function startChannelMessagePolling(channelName) {
        while (channelWindows[channelName]) {
          try {
            await updateChannelMessages(channelName);
            await new Promise((resolve) => setTimeout(resolve, 2000));
          } catch (e) {
            console.error("Channel polling error:", e);
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        }
      }

      // Update channel messages
      async function updateChannelMessages(channelName) {
        const data = await request("GET", "/api/messages");

        if (data.status === "success" && data.messages) {
          // Filter messages for this channel
          const channelMessages = data.messages.filter(
            (m) => m.type === "channel" && m.channel === channelName
          );

          const messagesDiv = document.getElementById(
            "channel-messages-" + channelName
          );
          if (!messagesDiv) return;

          let html = "";
          channelMessages.forEach((m) => {
            const isOwn = m.from === "You";
            html +=
              '<div class="channel-message' + (isOwn ? " own" : "") + '">';
            html += "<strong>" + m.from + ":</strong> " + m.content;
            html += "</div>";
          });

          messagesDiv.innerHTML = html;
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
      }

      async function loadMessages() {
        const data = await request("GET", "/api/messages");
        if (data.status === "success" && data.messages) {
          // Check timestamp for real updates
          if (
            data.timestamp &&
            data.timestamp > lastMessageTimestamp &&
            data.messages.length !== lastMessageCount
          ) {
            lastMessageCount = data.messages.length;
            lastMessageTimestamp = data.timestamp;

            let html = "";
            data.messages.forEach((m) => {
              let label = "";
              if (m.type === "broadcast") label = "[BROADCAST]";
              else if (m.type === "channel")
                label = "[CHANNEL: " + m.channel + "]";
              else if (m.to) label = "[TO: " + m.to + "]";
              else label = "[DIRECT]";

              html +=
                "<p><b>" + m.from + "</b> " + label + ": " + m.content + "</p>";
            });

            const messagesDiv = document.getElementById("messages");
            messagesDiv.innerHTML = html;

            // Auto-scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Show notification
            if (
              data.messages.length > 0 &&
              data.messages[data.messages.length - 1].from !== "You"
            ) {
              showStatus("New message received!");
            }
          }
        }
      }

      async function createChannel() {
        const name = document.getElementById("newChannel").value;
        if (!name) return;
        const data = await request("POST", "/api/channel/create", {
          channel: name,
        });
        if (data.status === "success") {
          showStatus("Channel created");
          document.getElementById("newChannel").value = "";
          loadChannels();
        } else {
          showStatus("Error: " + (data.message || "Unknown error"));
        }
      }

      async function joinChannel(name) {
        const data = await request("POST", "/api/channel/join", {
          channel: name,
        });
        if (data.status === "success") {
          showStatus("Joined " + name);
          loadChannels();
        } else {
          showStatus("Error: " + (data.message || "Unknown error"));
        }
      }

      async function sendDirect() {
        const to = document.getElementById("directTo").value;
        const msg = document.getElementById("directMsg").value;
        if (!to || !msg) return;
        const data = await request("POST", "/api/send", {
          to: to,
          message: msg,
        });
        if (data.status === "success") {
          showStatus("Sent to " + to);
          document.getElementById("directMsg").value = "";
          loadMessages();
        } else {
          showStatus("Error: " + (data.message || "Failed to send"));
        }
      }

      async function sendBroadcast() {
        const msg = document.getElementById("broadcastMsg").value;
        if (!msg) return;
        const data = await request("POST", "/api/broadcast", { message: msg });
        if (data.status === "success") {
          showStatus(data.message);
          document.getElementById("broadcastMsg").value = "";
          loadMessages();
        } else {
          showStatus("Error: " + (data.message || "Failed to broadcast"));
        }
      }

      // Long polling for real-time message notifications
      async function startMessagePolling() {
        while (true) {
          try {
            const data = await request("GET", "/api/messages/poll");
            
            if (data.has_new_messages) {
              // New messages arrived, reload immediately
              console.log(" New message detected! Reloading...");
              loadMessages();
              loadChannels();
            }
            
            // Continue polling immediately (no delay)
            
          } catch (error) {
            console.error("Long polling error:", error);
            // Wait a bit before retrying on error
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
        }
      }

      // Periodic polling for peer list and channels (every 10 seconds)
      setInterval(() => {
        loadPeers();
        loadChannels(); // Auto-refresh channels too
      }, 10000);

      // Initial load
      window.onload = async () => {
        const port = window.location.port;
        currentPeerId = "peer_" + port;

        loadPeers();
        loadChannels();
        loadMessages();
        
        // Start real-time long polling for messages
        console.log("ðŸš€ Starting long polling for real-time notifications...");
        startMessagePolling();
      };
    </script>
  </body>
</html>

